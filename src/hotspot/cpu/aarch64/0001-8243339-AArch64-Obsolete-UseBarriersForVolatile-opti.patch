From bc669dfc821f7f687acd815515aa4b4ad127ca3d Mon Sep 17 00:00:00 2001
From: Xiaohong Gong <xgong@openjdk.org>
Date: Wed, 27 May 2020 15:17:09 +0800
Subject: [PATCH] 8243339: AArch64: Obsolete UseBarriersForVolatile option

Reviewed-by: adinn, aph, drwhite
---
 src/hotspot/cpu/aarch64/aarch64.ad            |  39 +-
 .../cpu/aarch64/c1_LIRGenerator_aarch64.cpp   |   5 +-
 src/hotspot/cpu/aarch64/globals_aarch64.hpp   |   3 -
 .../cpu/aarch64/jniFastGetField_aarch64.cpp   |  27 +-
 .../cpu/aarch64/templateTable_aarch64.cpp     |   8 +-
 .../cpu/aarch64/vm_version_aarch64.cpp        |   6 +-
 .../cpu/aarch64/vm_version_aarch64.hpp        |   5 +-
 .../share/compiler/compilerDefinitions.cpp    |  41 +-
 .../share/compiler/compilerDefinitions.hpp    |   4 +-
 src/hotspot/share/jvmci/jvmciCompiler.cpp     |   1 +
 src/hotspot/share/jvmci/vmStructs_jvmci.cpp   |   3 +-
 src/hotspot/share/opto/c2compiler.cpp         |   3 +-
 src/hotspot/share/runtime/arguments.cpp       |   3 +
 .../src/jdk/vm/ci/aarch64/AArch64.java        |   6 +-
 .../AArch64HotSpotJVMCIBackendFactory.java    |   8 +-
 .../aarch64/AArch64HotSpotVMConfig.java       |   4 +-
 .../compiler/c2/aarch64/TestVolatiles.java    | 899 +++++-------------
 17 files changed, 313 insertions(+), 752 deletions(-)

diff --git a/src/hotspot/cpu/aarch64/aarch64.ad b/src/hotspot/cpu/aarch64/aarch64.ad
index eedc825c7ca..466ecaec0f9 100644
--- a/src/hotspot/cpu/aarch64/aarch64.ad
+++ b/src/hotspot/cpu/aarch64/aarch64.ad
@@ -1361,17 +1361,12 @@ source %{
   // traverse when searching from a card mark membar for the merge mem
   // feeding a trailing membar or vice versa
 
-// predicates controlling emit of ldr<x>/ldar<x> and associated dmb
+// predicates controlling emit of ldr<x>/ldar<x>
 
 bool unnecessary_acquire(const Node *barrier)
 {
   assert(barrier->is_MemBar(), "expecting a membar");
 
-  if (UseBarriersForVolatile) {
-    // we need to plant a dmb
-    return false;
-  }
-
   MemBarNode* mb = barrier->as_MemBar();
 
   if (mb->trailing_load()) {
@@ -1390,26 +1385,15 @@ bool unnecessary_acquire(const Node *barrier)
 bool needs_acquiring_load(const Node *n)
 {
   assert(n->is_Load(), "expecting a load");
-  if (UseBarriersForVolatile) {
-    // we use a normal load and a dmb
-    return false;
-  }
-
   LoadNode *ld = n->as_Load();
-
   return ld->is_acquire();
 }
 
 bool unnecessary_release(const Node *n)
 {
   assert((n->is_MemBar() &&
-	  n->Opcode() == Op_MemBarRelease),
-	 "expecting a release membar");
-
-  if (UseBarriersForVolatile) {
-    // we need to plant a dmb
-    return false;
-  }
+          n->Opcode() == Op_MemBarRelease),
+         "expecting a release membar");
 
   MemBarNode *barrier = n->as_MemBar();
   if (!barrier->leading()) {
@@ -1437,11 +1421,6 @@ bool unnecessary_release(const Node *n)
 bool unnecessary_volatile(const Node *n)
 {
   // assert n->is_MemBar();
-  if (UseBarriersForVolatile) {
-    // we need to plant a dmb
-    return false;
-  }
-
   MemBarNode *mbvol = n->as_MemBar();
 
   bool release = mbvol->trailing_store();
@@ -1458,18 +1437,12 @@ bool unnecessary_volatile(const Node *n)
   return release;
 }
 
-// predicates controlling emit of str<x>/stlr<x> and associated dmbs
+// predicates controlling emit of str<x>/stlr<x>
 
 bool needs_releasing_store(const Node *n)
 {
   // assert n->is_Store();
-  if (UseBarriersForVolatile) {
-    // we use a normal store and dmb combination
-    return false;
-  }
-
   StoreNode *st = n->as_Store();
-
   return st->trailing_membar() != NULL;
 }
 
@@ -1480,10 +1453,6 @@ bool needs_releasing_store(const Node *n)
 bool needs_acquiring_load_exclusive(const Node *n)
 {
   assert(is_CAS(n->Opcode(), true), "expecting a compare and swap");
-  if (UseBarriersForVolatile) {
-    return false;
-  }
-
   LoadStoreNode* ldst = n->as_LoadStore();
   if (is_CAS(n->Opcode(), false)) {
     assert(ldst->trailing_membar() != NULL, "expected trailing membar");
diff --git a/src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp b/src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp
index 312002e851a..43598039050 100644
--- a/src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
@@ -1411,9 +1411,8 @@ void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
   // membar it's possible for a simple Dekker test to fail if loads
   // use LD;DMB but stores use STLR.  This can happen if C2 compiles
   // the stores in one method and C1 compiles the loads in another.
-  if (! UseBarriersForVolatile) {
+  if (!is_c1_or_interpreter_only()) {
     __ membar();
   }
-
   __ volatile_load_mem_reg(address, result, info);
 }
diff --git a/src/hotspot/cpu/aarch64/globals_aarch64.hpp b/src/hotspot/cpu/aarch64/globals_aarch64.hpp
index f35a42cae2a..d34327a9d82 100644
--- a/src/hotspot/cpu/aarch64/globals_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/globals_aarch64.hpp
@@ -85,9 +85,6 @@ define_pd_global(intx, InlineSmallCode,          1000);
                                                                         \
   product(bool, NearCpool, true,                                        \
          "constant pool is close to instructions")                      \
-                                                                        \
-  product(bool, UseBarriersForVolatile, false,                          \
-          "Use memory barriers to implement volatile accesses")         \
   product(bool, UseNeon, false,                                         \
           "Use Neon for CRC32 computation")                             \
   product(bool, UseCRC32, false,                                        \
diff --git a/src/hotspot/cpu/aarch64/jniFastGetField_aarch64.cpp b/src/hotspot/cpu/aarch64/jniFastGetField_aarch64.cpp
index c31c3c2dd49..edbc3f93587 100644
--- a/src/hotspot/cpu/aarch64/jniFastGetField_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/jniFastGetField_aarch64.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
@@ -80,23 +80,12 @@ address JNI_FastGetField::generate_fast_get_int_field0(BasicType type) {
   __ ldrw(rcounter, safepoint_counter_addr);
   __ tbnz(rcounter, 0, slow);
 
-  if (!UseBarriersForVolatile) {
-    // Field may be volatile. See other usages of this flag.
-    __ membar(MacroAssembler::AnyAny);
-    __ mov(robj, c_rarg1);
-  } else if (JvmtiExport::can_post_field_access()) {
+  // It doesn't need to issue a full barrier here even if the field
+  // is volatile, since it has already used "ldar" for it.
+  if (JvmtiExport::can_post_field_access()) {
     // Using barrier to order wrt. JVMTI check and load of result.
     __ membar(Assembler::LoadLoad);
-    __ mov(robj, c_rarg1);
-  } else {
-    // Using address dependency to order wrt. load of result.
-    __ eor(robj, c_rarg1, rcounter);
-    __ eor(robj, robj, rcounter);         // obj, since
-                                          // robj ^ rcounter ^ rcounter == robj
-                                          // robj is address dependent on rcounter.
-  }
 
-  if (JvmtiExport::can_post_field_access()) {
     // Check to see if a field access watch has been set before we
     // take the fast path.
     unsigned long offset2;
@@ -105,6 +94,14 @@ address JNI_FastGetField::generate_fast_get_int_field0(BasicType type) {
             offset2);
     __ ldrw(result, Address(result, offset2));
     __ cbnzw(result, slow);
+
+    __ mov(robj, c_rarg1);
+  } else {
+    // Using address dependency to order wrt. load of result.
+    __ eor(robj, c_rarg1, rcounter);
+    __ eor(robj, robj, rcounter);         // obj, since
+                                          // robj ^ rcounter ^ rcounter == robj
+                                          // robj is address dependent on rcounter.
   }
 
   // Both robj and rscratch1 are clobbered by try_resolve_jobject_in_native.
diff --git a/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp b/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp
index a8ba062f932..19564abbd01 100644
--- a/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
@@ -2487,7 +2487,7 @@ void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteContr
   // membar it's possible for a simple Dekker test to fail if loads
   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
   // the stores in one method and we interpret the loads in another.
-  if (! UseBarriersForVolatile) {
+  if (!is_c1_or_interpreter_only()){
     Label notVolatile;
     __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
     __ membar(MacroAssembler::AnyAny);
@@ -3083,7 +3083,7 @@ void TemplateTable::fast_accessfield(TosState state)
   // membar it's possible for a simple Dekker test to fail if loads
   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
   // the stores in one method and we interpret the loads in another.
-  if (! UseBarriersForVolatile) {
+  if (!is_c1_or_interpreter_only()) {
     Label notVolatile;
     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
     __ membar(MacroAssembler::AnyAny);
@@ -3145,7 +3145,7 @@ void TemplateTable::fast_xaccess(TosState state)
   // membar it's possible for a simple Dekker test to fail if loads
   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
   // the stores in one method and we interpret the loads in another.
-  if (! UseBarriersForVolatile) {
+  if (!is_c1_or_interpreter_only()) {
     Label notVolatile;
     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
                                      ConstantPoolCacheEntry::flags_offset())));
diff --git a/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp b/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp
index 515f8736ea5..7d477c04b27 100644
--- a/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp
@@ -220,7 +220,7 @@ void VM_Version::get_processor_features() {
 
   // ThunderX
   if (_cpu == CPU_CAVIUM && (_model == 0xA1)) {
-    if (_variant == 0) _features |= CPU_DMB_ATOMICS;
+    guarantee(_variant != 0, "Pre-release hardware no longer supported.");
     if (FLAG_IS_DEFAULT(AvoidUnalignedAccesses)) {
       FLAG_SET_DEFAULT(AvoidUnalignedAccesses, true);
     }
@@ -420,10 +420,6 @@ void VM_Version::get_processor_features() {
     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
   }
 
-  if (FLAG_IS_DEFAULT(UseBarriersForVolatile)) {
-    UseBarriersForVolatile = (_features & CPU_DMB_ATOMICS) != 0;
-  }
-
   if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
     FLAG_SET_DEFAULT(UsePopCountInstruction, true);
   }
diff --git a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
index a4cf9bc49d8..91bba66fa34 100644
--- a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -98,7 +98,6 @@ class VM_Version : public Abstract_VM_Version {
     CPU_LSE          = (1<<8),
     CPU_STXR_PREFETCH= (1 << 29),
     CPU_A53MAC       = (1 << 30),
-    CPU_DMB_ATOMICS  = (1 << 31),
   };
 
   static int cpu_family()                     { return _cpu; }
diff --git a/src/hotspot/share/compiler/compilerDefinitions.cpp b/src/hotspot/share/compiler/compilerDefinitions.cpp
index 33442dd9b12..011494af95b 100644
--- a/src/hotspot/share/compiler/compilerDefinitions.cpp
+++ b/src/hotspot/share/compiler/compilerDefinitions.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -517,3 +517,42 @@ void CompilerConfig::ergo_initialize() {
   }
 #endif // COMPILER2
 }
+
+static CompLevel highest_compile_level() {
+  return TieredCompilation ? MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier) : CompLevel_highest_tier;
+}
+
+bool is_c1_or_interpreter_only() {
+  if (Arguments::is_interpreter_only()) {
+    return true;
+  }
+
+#if INCLUDE_AOT
+  if (UseAOT) {
+    return false;
+  }
+#endif
+
+  if (highest_compile_level() < CompLevel_full_optimization) {
+#if INCLUDE_JVMCI
+    if (TieredCompilation) {
+       return true;
+    }
+    // This happens on jvm variant with C2 disabled and JVMCI
+    // enabled.
+    return !UseJVMCICompiler;
+#else
+    return true;
+#endif
+  }
+
+#ifdef TIERED
+  // The quick-only compilation mode is c1 only. However,
+  // CompilationModeFlag only takes effect with TieredCompilation
+  // enabled.
+  if (TieredCompilation && CompilationModeFlag::quick_only()) {
+    return true;
+  }
+#endif
+  return false;
+}
diff --git a/src/hotspot/share/compiler/compilerDefinitions.hpp b/src/hotspot/share/compiler/compilerDefinitions.hpp
index d347d0e3c9c..d8cc1c1f21a 100644
--- a/src/hotspot/share/compiler/compilerDefinitions.hpp
+++ b/src/hotspot/share/compiler/compilerDefinitions.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -116,6 +116,8 @@ inline bool is_compile(int comp_level) {
   return is_c1_compile(comp_level) || is_c2_compile(comp_level);
 }
 
+bool is_c1_or_interpreter_only();
+
 // States of Restricted Transactional Memory usage.
 enum RTMState {
   NoRTM      = 0x2, // Don't use RTM
diff --git a/src/hotspot/share/jvmci/jvmciCompiler.cpp b/src/hotspot/share/jvmci/jvmciCompiler.cpp
index 73fc48bd05a..6d5dc16bd53 100644
--- a/src/hotspot/share/jvmci/jvmciCompiler.cpp
+++ b/src/hotspot/share/jvmci/jvmciCompiler.cpp
@@ -42,6 +42,7 @@ JVMCICompiler::JVMCICompiler() : AbstractCompiler(compiler_jvmci) {
 
 // Initialization
 void JVMCICompiler::initialize() {
+  assert(!is_c1_or_interpreter_only(), "JVMCI is launched, it's not c1/interpreter only mode");
   if (!UseCompiler || !EnableJVMCI || !UseJVMCICompiler || !should_perform_init()) {
     return;
   }
diff --git a/src/hotspot/share/jvmci/vmStructs_jvmci.cpp b/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
index 6672f85ce07..91fe38c9efa 100644
--- a/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
+++ b/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
@@ -725,8 +725,7 @@
   declare_constant(VM_Version::CPU_CRC32)               \
   declare_constant(VM_Version::CPU_LSE)                 \
   declare_constant(VM_Version::CPU_STXR_PREFETCH)       \
-  declare_constant(VM_Version::CPU_A53MAC)              \
-  declare_constant(VM_Version::CPU_DMB_ATOMICS)
+  declare_constant(VM_Version::CPU_A53MAC)
 
 #endif
 
diff --git a/src/hotspot/share/opto/c2compiler.cpp b/src/hotspot/share/opto/c2compiler.cpp
index 9495ac2fb43..6f554dea07b 100644
--- a/src/hotspot/share/opto/c2compiler.cpp
+++ b/src/hotspot/share/opto/c2compiler.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -84,6 +84,7 @@ bool C2Compiler::init_c2_runtime() {
 }
 
 void C2Compiler::initialize() {
+  assert(!is_c1_or_interpreter_only(), "C2 compiler is launched, it's not c1/interpreter only mode");
   // The first compiler thread that gets here will initialize the
   // small amount of global state (and runtime stubs) that C2 needs.
 
diff --git a/src/hotspot/share/runtime/arguments.cpp b/src/hotspot/share/runtime/arguments.cpp
index bbb845b1fc7..f57377b0560 100644
--- a/src/hotspot/share/runtime/arguments.cpp
+++ b/src/hotspot/share/runtime/arguments.cpp
@@ -560,6 +560,9 @@ static SpecialFlag const special_jvm_flags[] = {
 #endif // !X86
   { "UseAdaptiveGCBoundary",         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
   { "MonitorBound",                  JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
+#ifdef AARCH64
+  { "UseBarriersForVolatile",        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
+#endif
 
 #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
   // These entries will generate build errors.  Their purpose is to test the macros.
diff --git a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.aarch64/src/jdk/vm/ci/aarch64/AArch64.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.aarch64/src/jdk/vm/ci/aarch64/AArch64.java
index b147b5b3aca..8f2bc6122b4 100644
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.aarch64/src/jdk/vm/ci/aarch64/AArch64.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.aarch64/src/jdk/vm/ci/aarch64/AArch64.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -173,8 +173,7 @@ public enum CPUFeature {
         CRC32,
         LSE,
         STXR_PREFETCH,
-        A53MAC,
-        DMB_ATOMICS
+        A53MAC
     }
 
     private final EnumSet<CPUFeature> features;
@@ -183,7 +182,6 @@ public enum CPUFeature {
      * Set of flags to control code emission.
      */
     public enum Flag {
-        UseBarriersForVolatile,
         UseCRC32,
         UseNeon,
         UseSIMDForMemoryOps,
diff --git a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotJVMCIBackendFactory.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotJVMCIBackendFactory.java
index 2c96618ee47..650d3f048af 100644
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotJVMCIBackendFactory.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotJVMCIBackendFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -80,9 +80,6 @@ private static EnumSet<AArch64.CPUFeature> computeFeatures(@SuppressWarnings("un
         if ((config.vmVersionFeatures & config.aarch64A53MAC) != 0) {
             features.add(AArch64.CPUFeature.A53MAC);
         }
-        if ((config.vmVersionFeatures & config.aarch64DMB_ATOMICS) != 0) {
-            features.add(AArch64.CPUFeature.DMB_ATOMICS);
-        }
 
         return features;
     }
@@ -90,9 +87,6 @@ private static EnumSet<AArch64.CPUFeature> computeFeatures(@SuppressWarnings("un
     private static EnumSet<AArch64.Flag> computeFlags(@SuppressWarnings("unused") AArch64HotSpotVMConfig config) {
         EnumSet<AArch64.Flag> flags = EnumSet.noneOf(AArch64.Flag.class);
 
-        if (config.useBarriersForVolatile) {
-            flags.add(AArch64.Flag.UseBarriersForVolatile);
-        }
         if (config.useCRC32) {
             flags.add(AArch64.Flag.UseCRC32);
         }
diff --git a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotVMConfig.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotVMConfig.java
index c7efa031c14..fa28dacc6e5 100644
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotVMConfig.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotVMConfig.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -46,7 +46,6 @@ class AArch64HotSpotVMConfig extends HotSpotVMConfigAccess {
     /*
      * These flags are set based on the corresponding command line flags.
      */
-    final boolean useBarriersForVolatile = getFlag("UseBarriersForVolatile", Boolean.class);
     final boolean useCRC32 = getFlag("UseCRC32", Boolean.class);
     final boolean useNeon = getFlag("UseNeon", Boolean.class);
     final boolean useSIMDForMemoryOps = getFlag("UseSIMDForMemoryOps", Boolean.class);
@@ -71,6 +70,5 @@ class AArch64HotSpotVMConfig extends HotSpotVMConfigAccess {
     final long aarch64LSE = getConstant("VM_Version::CPU_LSE", Long.class);
     final long aarch64STXR_PREFETCH = getConstant("VM_Version::CPU_STXR_PREFETCH", Long.class);
     final long aarch64A53MAC = getConstant("VM_Version::CPU_A53MAC", Long.class);
-    final long aarch64DMB_ATOMICS = getConstant("VM_Version::CPU_DMB_ATOMICS", Long.class);
     // Checkstyle: resume
 }
diff --git a/test/hotspot/jtreg/compiler/c2/aarch64/TestVolatiles.java b/test/hotspot/jtreg/compiler/c2/aarch64/TestVolatiles.java
index abe3a5e3f10..ec4db0af306 100644
--- a/test/hotspot/jtreg/compiler/c2/aarch64/TestVolatiles.java
+++ b/test/hotspot/jtreg/compiler/c2/aarch64/TestVolatiles.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.
+ * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -74,28 +74,28 @@ public void runtest(String classname, String testType) throws Throwable {
         // i.e. GC type plus GC conifg
         switch(testType) {
         case "G1":
-            argcount = 9;
+            argcount = 8;
             procArgs = new String[argcount];
             procArgs[argcount - 2] = "-XX:+UseG1GC";
             break;
         case "Parallel":
-            argcount = 9;
+            argcount = 8;
             procArgs = new String[argcount];
             procArgs[argcount - 2] = "-XX:+UseParallelGC";
             break;
         case "Serial":
-            argcount = 9;
+            argcount = 8;
             procArgs = new String[argcount];
             procArgs[argcount - 2] = "-XX:+UseSerialGC";
             break;
         case "Shenandoah":
-            argcount = 10;
+            argcount = 9;
             procArgs = new String[argcount];
             procArgs[argcount - 3] = "-XX:+UnlockExperimentalVMOptions";
             procArgs[argcount - 2] = "-XX:+UseShenandoahGC";
             break;
         case "ShenandoahIU":
-            argcount = 11;
+            argcount = 10;
             procArgs = new String[argcount];
             procArgs[argcount - 4] = "-XX:+UnlockExperimentalVMOptions";
             procArgs[argcount - 3] = "-XX:+UseShenandoahGC";
@@ -112,35 +112,24 @@ public void runtest(String classname, String testType) throws Throwable {
         // zero appropriately. this arg is reset in the second run to
         // disable the transform.
 
-        procArgs[0] = "-XX:-UseBarriersForVolatile";
-        procArgs[1] = "-XX:+UseCompressedOops";
-
-        procArgs[2] = "-XX:-TieredCompilation";
-        procArgs[3] = "-XX:+PrintOptoAssembly";
-        procArgs[4] = "-XX:CompileCommand=compileonly," + fullclassname + "::" + "test*";
-        procArgs[5] = "--add-exports";
-        procArgs[6] = "java.base/jdk.internal.misc=ALL-UNNAMED";
+        procArgs[0] = "-XX:+UseCompressedOops";
+        procArgs[1] = "-XX:-TieredCompilation";
+        procArgs[2] = "-XX:+PrintOptoAssembly";
+        procArgs[3] = "-XX:CompileCommand=compileonly," + fullclassname + "::" + "test*";
+        procArgs[4] = "--add-exports";
+        procArgs[5] = "java.base/jdk.internal.misc=ALL-UNNAMED";
         procArgs[argcount - 1] = fullclassname;
 
-        runtest(classname, testType, false, true, procArgs);
-        // rerun the test class without the transform applied and
-        // check the alternative generation is as expected
-
-        procArgs[0] = "-XX:+UseBarriersForVolatile";
-        runtest(classname, testType, true, true, procArgs);
+        runtest(classname, testType, true, procArgs);
 
         if (!classname.equals("TestUnsafeVolatileGAA")) {
-            procArgs[0] = "-XX:-UseBarriersForVolatile";
-            procArgs[1] = "-XX:-UseCompressedOops";
-            runtest(classname, testType, false, false, procArgs);
-
-            procArgs[0] = "-XX:+UseBarriersForVolatile";
-            runtest(classname, testType, true, false, procArgs);
+            procArgs[0] = "-XX:-UseCompressedOops";
+            runtest(classname, testType, false, procArgs);
         }
     }
 
 
-    public void runtest(String classname, String testType, boolean useBarriersForVolatile, boolean useCompressedOops, String[] procArgs) throws Throwable {
+    public void runtest(String classname, String testType, boolean useCompressedOops, String[] procArgs) throws Throwable {
         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(procArgs);
         OutputAnalyzer output = new OutputAnalyzer(pb.start());
 
@@ -152,7 +141,7 @@ public void runtest(String classname, String testType, boolean useBarriersForVol
         // appropriate to test class, test type and whether transform
         // was applied
 
-        checkoutput(output, classname, testType, useBarriersForVolatile, useCompressedOops);
+        checkoutput(output, classname, testType, useCompressedOops);
     }
 
     // skip through output returning a line containing the desireed
@@ -223,7 +212,7 @@ private boolean checkCompile(Iterator<String> iter, String methodname, String[]
 
     // check for expected asm output from a volatile load
 
-    private void checkload(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
+    private void checkload(OutputAnalyzer output, String testType, boolean useCompressedOops) throws Throwable
     {
         Iterator<String> iter = output.asLines().listIterator();
 
@@ -231,198 +220,80 @@ private void checkload(OutputAnalyzer output, String testType, boolean useBarrie
         // for both int and Object fields
 
         String[] matches;
-
-        if (!useBarriersForVolatile) {
-            matches = new String[] {
-                "ldarw",
-                "membar_acquire \\(elided\\)",
-                "ret"
-            };
-        } else {
-            matches = new String[] {
-                "ldrw",
-                "membar_acquire",
-                "dmb ish",
-                "ret"
-            };
-        }
-
+        matches = new String[] {
+            "ldarw",
+            "membar_acquire \\(elided\\)",
+            "ret"
+        };
         checkCompile(iter, "testInt", matches, output, true);
 
-        if (!useBarriersForVolatile) {
-            matches = new String[] {
-                useCompressedOops ? "ldarw?" : "ldar",
-                "membar_acquire \\(elided\\)",
-                "ret"
-            };
-        } else {
-            matches = new String[] {
-                useCompressedOops ? "ldrw?" : "ldr",
-                "membar_acquire",
-                "dmb ish",
-                "ret"
-            };
-        }
-
+        matches = new String[] {
+            useCompressedOops ? "ldarw?" : "ldar",
+            "membar_acquire \\(elided\\)",
+            "ret"
+        };
         checkCompile(iter, "testObj", matches, output, true);
 
     }
 
     // check for expected asm output from a volatile store
 
-    private void checkstore(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
+    private void checkstore(OutputAnalyzer output, String testType, boolean useCompressedOops) throws Throwable
     {
         Iterator<String> iter = output.asLines().listIterator();
 
         String[] matches;
 
         // non object stores are straightforward
-        if (!useBarriersForVolatile) {
-            // this is the sequence of instructions for all cases
+        // this is the sequence of instructions for all cases
+        matches = new String[] {
+            "membar_release \\(elided\\)",
+            "stlrw",
+            "membar_volatile \\(elided\\)",
+            "ret"
+        };
+        checkCompile(iter, "testInt", matches, output, true);
+
+        // object stores will be as above except for when the GC
+        // introduces barriers for card marking
+        switch (testType) {
+        default:
+            // this is the basic sequence of instructions
             matches = new String[] {
                 "membar_release \\(elided\\)",
-                "stlrw",
+                useCompressedOops ? "stlrw?" : "stlr",
                 "membar_volatile \\(elided\\)",
                 "ret"
             };
-        } else {
-            // this is the alternative sequence of instructions
+            break;
+        case "G1":
+            // a card mark volatile barrier should be generated
+            // before the card mark strb
+            //
+            // following the fix for 8225776 the G1 barrier is now
+            // scheduled out of line after the membar volatile and
+            // and subsequent return
             matches = new String[] {
-                "membar_release",
-                "dmb ish",
-                "strw",
+                "membar_release \\(elided\\)",
+                useCompressedOops ? "stlrw?" : "stlr",
+                "membar_volatile \\(elided\\)",
+                "ret",
                 "membar_volatile",
                 "dmb ish",
+                "strb"
+            };
+            break;
+        case "Shenandoah":
+        case "ShenandoahIU":
+             // Shenandoah generates normal object graphs for
+             // volatile stores
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                useCompressedOops ? "stlrw?" : "stlr",
+                "membar_volatile \\(elided\\)",
                 "ret"
             };
-        }
-
-        checkCompile(iter, "testInt", matches, output, true);
-
-        // object stores will be as above except for when the GC
-        // introduces barriers for card marking
-
-        if (!useBarriersForVolatile) {
-            switch (testType) {
-            default:
-                // this is the basic sequence of instructions
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    useCompressedOops ? "stlrw?" : "stlr",
-                    "membar_volatile \\(elided\\)",
-                    "ret"
-                };
-                break;
-            case "G1":
-                // a card mark volatile barrier should be generated
-                // before the card mark strb
-                //
-                // following the fix for 8225776 the G1 barrier is now
-                // scheduled out of line after the membar volatile and
-                // and subsequent return
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    useCompressedOops ? "stlrw?" : "stlr",
-                    "membar_volatile \\(elided\\)",
-                    "ret",
-                    "membar_volatile",
-                    "dmb ish",
-                    "strb"
-                };
-                break;
-            case "Shenandoah":
-            case "ShenandoahIU":
-                 // Shenandoah generates normal object graphs for
-                 // volatile stores
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    useCompressedOops ? "stlrw?" : "stlr",
-                    "membar_volatile \\(elided\\)",
-                    "ret"
-                };
-                break;
-            }
-        } else {
-            switch (testType) {
-            default:
-                // this is the basic sequence of instructions
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "strw?" : "str",
-                    "membar_volatile",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            case "G1":
-                // a card mark volatile barrier should be generated
-                // before the card mark strb
-                //
-                // following the fix for 8225776 the G1 barrier is now
-                // scheduled out of line after the membar volatile and
-                // and subsequent return
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "strw?" : "str",
-                    "membar_volatile",
-                    "dmb ish",
-                    "ret",
-                    "membar_volatile",
-                    "dmb ish",
-                    "strb"
-                };
-                break;
-            case "CMSCondMark":
-                // a card mark volatile barrier should be generated
-                // before the card mark strb from the StoreCM and the
-                // storestore barrier from the StoreCM should be elided
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "strw?" : "str",
-                    "membar_volatile",
-                    "dmb ish",
-                    "storestore \\(elided\\)",
-                    "strb",
-                    "membar_volatile",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            case "CMS":
-                // a volatile card mark membar should not be generated
-                // before the card mark strb from the StoreCM and the
-                // storestore barrier from the StoreCM should be generated
-                // as "dmb ishst"
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "strw?" : "str",
-                    "storestore",
-                    "dmb ishst",
-                    "strb",
-                    "membar_volatile",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-
-            case "Shenandoah":
-            case "ShenandoahIU":
-                 // Shenandoah generates normal object graphs for
-                 // volatile stores
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "strw?" : "str",
-                    "membar_volatile",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            }
+            break;
         }
 
         checkCompile(iter, "testObj", matches, output, true);
@@ -430,7 +301,7 @@ private void checkstore(OutputAnalyzer output, String testType, boolean useBarri
 
     // check for expected asm output from a volatile cas
 
-    private void checkcas(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
+    private void checkcas(OutputAnalyzer output, String testType, boolean useCompressedOops) throws Throwable
     {
         Iterator<String> iter = output.asLines().listIterator();
 
@@ -444,159 +315,62 @@ private void checkcas(OutputAnalyzer output, String testType, boolean useBarrier
 
         for (String[] test : tests) {
             // non object stores are straightforward
-            if (!useBarriersForVolatile) {
-                // this is the sequence of instructions for all cases
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    test[1] + "_acq",
-                    "membar_acquire \\(elided\\)",
-                    "ret"
-                };
-            } else {
-                // this is the alternative sequence of instructions
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    test[1] + " ",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-            }
-
+            // this is the sequence of instructions for all cases
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                test[1] + "_acq",
+                "membar_acquire \\(elided\\)",
+                "ret"
+            };
             checkCompile(iter, test[0], matches, output, true);
         }
 
         // object stores will be as above except for when the GC
         // introduces barriers for card marking
-
-        if (!useBarriersForVolatile) {
-            switch (testType) {
-            default:
-                // this is the basic sequence of instructions
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    useCompressedOops ? "cmpxchgw?_acq" : "cmpxchg_acq",
-                    "strb",
-                    "membar_acquire \\(elided\\)",
-                    "ret"
-                };
-                break;
-            case "G1":
-                // a card mark volatile barrier should be generated
-                // before the card mark strb
-                //
-                // following the fix for 8225776 the G1 barrier is now
-                // scheduled out of line after the membar acquire and
-                // and subsequent return
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    useCompressedOops ? "cmpxchgw?_acq" : "cmpxchg_acq",
-                    "membar_acquire \\(elided\\)",
-                    "ret",
-                    "membar_volatile",
-                    "dmb ish",
-                    "strb"
-                };
-                break;
-            case "Shenandoah":
-            case "ShenandoahIU":
-                // For volatile CAS, Shenanodoah generates normal
-                // graphs with a shenandoah-specific cmpxchg
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    useCompressedOops ? "cmpxchgw?_acq_shenandoah" : "cmpxchg_acq_shenandoah",
-                    "membar_acquire \\(elided\\)",
-                    "ret"
-                };
-                break;
-            }
-        } else {
-            switch (testType) {
-            default:
-                // this is the basic sequence of instructions
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "cmpxchgw? " : "cmpxchg ",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            case "G1":
-                // a card mark volatile barrier should be generated
-                // before the card mark strb
-                //
-                // following the fix for 8225776 the G1 barrier is now
-                // scheduled out of line after the membar acquire and
-                // and subsequent return
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "cmpxchgw? " : "cmpxchg ",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret",
-                    "membar_volatile",
-                    "dmb ish",
-                    "strb"
-                };
-                break;
-            case "CMSCondMark":
-                // a card mark volatile barrier should be generated
-                // before the card mark strb from the StoreCM and the
-                // storestore barrier from the StoreCM should be elided
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "cmpxchgw? " : "cmpxchg ",
-                    "membar_volatile",
-                    "dmb ish",
-                    "storestore \\(elided\\)",
-                    "strb",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            case "CMS":
-                // a volatile card mark membar should not be generated
-                // before the card mark strb from the StoreCM and the
-                // storestore barrier from the StoreCM should be generated
-                // as "dmb ishst"
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "cmpxchgw? " : "cmpxchg ",
-                    "storestore",
-                    "dmb ishst",
-                    "strb",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            case "Shenandoah":
-            case "ShenandoahIU":
-                // For volatile CAS, Shenanodoah generates normal
-                // graphs with a shenandoah-specific cmpxchg
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "cmpxchgw?_shenandoah" : "cmpxchg_shenandoah",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            }
+        switch (testType) {
+        default:
+            // this is the basic sequence of instructions
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                useCompressedOops ? "cmpxchgw?_acq" : "cmpxchg_acq",
+                "strb",
+                "membar_acquire \\(elided\\)",
+                "ret"
+            };
+            break;
+        case "G1":
+            // a card mark volatile barrier should be generated
+            // before the card mark strb
+            //
+            // following the fix for 8225776 the G1 barrier is now
+            // scheduled out of line after the membar acquire and
+            // and subsequent return
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                useCompressedOops ? "cmpxchgw?_acq" : "cmpxchg_acq",
+                "membar_acquire \\(elided\\)",
+                "ret",
+                "membar_volatile",
+                "dmb ish",
+                "strb"
+            };
+            break;
+        case "Shenandoah":
+        case "ShenandoahIU":
+            // For volatile CAS, Shenanodoah generates normal
+            // graphs with a shenandoah-specific cmpxchg
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                useCompressedOops ? "cmpxchgw?_acq_shenandoah" : "cmpxchg_acq_shenandoah",
+                "membar_acquire \\(elided\\)",
+                "ret"
+            };
+            break;
         }
-
         checkCompile(iter, "testObj", matches, output, true);
     }
 
-    private void checkcae(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
+    private void checkcae(OutputAnalyzer output, String testType, boolean useCompressedOops) throws Throwable
     {
         ListIterator<String> iter = output.asLines().listIterator();
 
@@ -610,177 +384,80 @@ private void checkcae(OutputAnalyzer output, String testType, boolean useBarrier
 
         for (String[] test : tests) {
             // non object stores are straightforward
-            if (!useBarriersForVolatile) {
-                // this is the sequence of instructions for all cases
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    test[1] + "_acq",
-                    "membar_acquire \\(elided\\)",
-                    "ret"
-                };
-            } else {
-                // this is the alternative sequence of instructions
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    test[1] + " ",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-            }
-
+            // this is the sequence of instructions for all cases
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                test[1] + "_acq",
+                "membar_acquire \\(elided\\)",
+                "ret"
+            };
             checkCompile(iter, test[0], matches, output, true);
         }
 
         // object stores will be as above except for when the GC
         // introduces barriers for card marking
+        switch (testType) {
+        default:
+            // this is the basic sequence of instructions
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                "strb",
+                useCompressedOops ? "cmpxchgw?_acq" : "cmpxchg_acq",
+                "membar_acquire \\(elided\\)",
+                "ret"
+            };
 
-        if (!useBarriersForVolatile) {
-            switch (testType) {
-            default:
-                // this is the basic sequence of instructions
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    "strb",
-                    useCompressedOops ? "cmpxchgw?_acq" : "cmpxchg_acq",
-                    "membar_acquire \\(elided\\)",
-                    "ret"
-                };
+            // card marking store may be scheduled before or after
+            // the cmpxchg so try both sequences.
+            int idx = iter.nextIndex();
+            if (!checkCompile(iter, "testObj", matches, output, false)) {
+                iter = output.asLines().listIterator(idx);
 
-                // card marking store may be scheduled before or after
-                // the cmpxchg so try both sequences.
-                int idx = iter.nextIndex();
-                if (!checkCompile(iter, "testObj", matches, output, false)) {
-                    iter = output.asLines().listIterator(idx);
-
-                    matches = new String[] {
-                        "membar_release \\(elided\\)",
-                        useCompressedOops ? "cmpxchgw?_acq" : "cmpxchg_acq",
-                        "strb",
-                        "membar_acquire \\(elided\\)",
-                        "ret"
-                    };
-
-                    checkCompile(iter, "testObj", matches, output, true);
-                }
-                return;
-
-            case "G1":
-                // a card mark volatile barrier should be generated
-                // before the card mark strb
-                //
-                // following the fix for 8225776 the G1 barrier is now
-                // scheduled out of line after the membar acquire and
-                // and subsequent return
                 matches = new String[] {
                     "membar_release \\(elided\\)",
                     useCompressedOops ? "cmpxchgw?_acq" : "cmpxchg_acq",
-                    "membar_acquire \\(elided\\)",
-                    "ret",
-                    "membar_volatile",
-                    "dmb ish",
-                    "strb"
-                };
-                break;
-            case "Shenandoah":
-            case "ShenandoahIU":
-                // For volatile CAS, Shenanodoah generates normal
-                // graphs with a shenandoah-specific cmpxchg
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    useCompressedOops ? "cmpxchgw?_acq_shenandoah" : "cmpxchg_acq_shenandoah",
-                    "membar_acquire \\(elided\\)",
-                    "ret"
-                };
-                break;
-            }
-        } else {
-            switch (testType) {
-            default:
-                // this is the basic sequence of instructions
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "cmpxchgw? " : "cmpxchg ",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            case "G1":
-                // a card mark volatile barrier should be generated
-                // before the card mark strb
-                //
-                // following the fix for 8225776 the G1 barrier is now
-                // scheduled out of line after the membar acquire and
-                // and subsequent return
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "cmpxchgw? " : "cmpxchg ",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret",
-                    "membar_volatile",
-                    "dmb ish",
-                    "strb"
-                };
-                break;
-            case "CMSCondMark":
-                // a card mark volatile barrier should be generated
-                // before the card mark strb from the StoreCM and the
-                // storestore barrier from the StoreCM should be elided
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "cmpxchgw? " : "cmpxchg ",
-                    "membar_volatile",
-                    "dmb ish",
-                    "storestore \\(elided\\)",
                     "strb",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            case "CMS":
-                // a volatile card mark membar should not be generated
-                // before the card mark strb from the StoreCM and the
-                // storestore barrier from the StoreCM should be generated
-                // as "dmb ishst"
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "cmpxchgw? " : "cmpxchg ",
-                    "storestore",
-                    "dmb ishst",
-                    "strb",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            case "Shenandoah":
-            case "ShenandoahIU":
-                // For volatile CAS, Shenanodoah generates normal
-                // graphs with a shenandoah-specific cmpxchg
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "cmpxchgw?_shenandoah" : "cmpxchg_shenandoah",
-                    "membar_acquire",
-                    "dmb ish",
+                    "membar_acquire \\(elided\\)",
                     "ret"
                 };
-                break;
+
+                checkCompile(iter, "testObj", matches, output, true);
             }
-        }
+            return;
 
+        case "G1":
+            // a card mark volatile barrier should be generated
+            // before the card mark strb
+            //
+            // following the fix for 8225776 the G1 barrier is now
+            // scheduled out of line after the membar acquire and
+            // and subsequent return
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                useCompressedOops ? "cmpxchgw?_acq" : "cmpxchg_acq",
+                "membar_acquire \\(elided\\)",
+                "ret",
+                "membar_volatile",
+                "dmb ish",
+                "strb"
+            };
+            break;
+        case "Shenandoah":
+        case "ShenandoahIU":
+            // For volatile CAS, Shenanodoah generates normal
+            // graphs with a shenandoah-specific cmpxchg
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                useCompressedOops ? "cmpxchgw?_acq_shenandoah" : "cmpxchg_acq_shenandoah",
+                "membar_acquire \\(elided\\)",
+                "ret"
+            };
+            break;
+        }
         checkCompile(iter, "testObj", matches, output, true);
     }
 
-    private void checkgas(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
+    private void checkgas(OutputAnalyzer output, String testType, boolean useCompressedOops) throws Throwable
     {
         Iterator<String> iter = output.asLines().listIterator();
 
@@ -792,155 +469,61 @@ private void checkgas(OutputAnalyzer output, String testType, boolean useBarrier
 
         for (String[] test : tests) {
             // non object stores are straightforward
-            if (!useBarriersForVolatile) {
-                // this is the sequence of instructions for all cases
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    test[1] + "_acq",
-                    "membar_acquire \\(elided\\)",
-                    "ret"
-                };
-            } else {
-                // this is the alternative sequence of instructions
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    test[1] + " ",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-            }
-
+            // this is the sequence of instructions for all cases
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                test[1] + "_acq",
+                "membar_acquire \\(elided\\)",
+                "ret"
+            };
             checkCompile(iter, test[0], matches, output, true);
         }
 
         // object stores will be as above except for when the GC
         // introduces barriers for card marking
-
-        if (!useBarriersForVolatile) {
-            switch (testType) {
-            default:
-                // this is the basic sequence of instructions
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    useCompressedOops ? "atomic_xchgw?_acq" : "atomic_xchg_acq",
-                    "strb",
-                    "membar_acquire \\(elided\\)",
-                    "ret"
-                };
-                break;
-            case "G1":
-                // a card mark volatile barrier should be generated
-                // before the card mark strb
-                //
-                // following the fix for 8225776 the G1 barrier is now
-                // scheduled out of line after the membar acquire and
-                // and subsequent return
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    useCompressedOops ? "atomic_xchgw?_acq" : "atomic_xchg_acq",
-                    "membar_acquire \\(elided\\)",
-                    "ret",
-                    "membar_volatile",
-                    "dmb ish",
-                    "strb"
-                };
-                break;
-            case "Shenandoah":
-            case "ShenandoahIU":
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    useCompressedOops ? "atomic_xchgw?_acq" : "atomic_xchg_acq",
-                    "membar_acquire \\(elided\\)",
-                    "ret"
-                };
-                break;
-            }
-        } else {
-            switch (testType) {
-            default:
-                // this is the basic sequence of instructions
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "atomic_xchgw? " : "atomic_xchg ",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            case "G1":
-                // a card mark volatile barrier should be generated
-                // before the card mark strb
-                //
-                // following the fix for 8225776 the G1 barrier is now
-                // scheduled out of line after the membar acquire and
-                // and subsequent return
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "atomic_xchgw? " : "atomic_xchg ",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret",
-                    "membar_volatile",
-                    "dmb ish",
-                    "strb"
-                };
-                break;
-            case "CMSCondMark":
-                // a card mark volatile barrier should be generated
-                // before the card mark strb from the StoreCM and the
-                // storestore barrier from the StoreCM should be elided
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "atomic_xchgw? " : "atomic_xchg ",
-                    "membar_volatile",
-                    "dmb ish",
-                    "storestore \\(elided\\)",
-                    "strb",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            case "CMS":
-                // a volatile card mark membar should not be generated
-                // before the card mark strb from the StoreCM and the
-                // storestore barrier from the StoreCM should be generated
-                // as "dmb ishst"
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "atomic_xchgw? " : "atomic_xchg ",
-                    "storestore",
-                    "dmb ishst",
-                    "strb",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            case "Shenandoah":
-            case "ShenandoahIU":
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    useCompressedOops ? "atomic_xchgw? " : "atomic_xchg ",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-                break;
-            }
+        switch (testType) {
+        default:
+            // this is the basic sequence of instructions
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                useCompressedOops ? "atomic_xchgw?_acq" : "atomic_xchg_acq",
+                "strb",
+                "membar_acquire \\(elided\\)",
+                "ret"
+            };
+            break;
+        case "G1":
+            // a card mark volatile barrier should be generated
+            // before the card mark strb
+            //
+            // following the fix for 8225776 the G1 barrier is now
+            // scheduled out of line after the membar acquire and
+            // and subsequent return
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                useCompressedOops ? "atomic_xchgw?_acq" : "atomic_xchg_acq",
+                "membar_acquire \\(elided\\)",
+                "ret",
+                "membar_volatile",
+                "dmb ish",
+                "strb"
+            };
+            break;
+        case "Shenandoah":
+        case "ShenandoahIU":
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                useCompressedOops ? "atomic_xchgw?_acq" : "atomic_xchg_acq",
+                "membar_acquire \\(elided\\)",
+                "ret"
+            };
+            break;
         }
 
         checkCompile(iter, "testObj", matches, output, true);
     }
 
-    private void checkgaa(OutputAnalyzer output, String testType, boolean useBarriersForVolatile) throws Throwable
+    private void checkgaa(OutputAnalyzer output, String testType) throws Throwable
     {
         Iterator<String> iter = output.asLines().listIterator();
 
@@ -952,26 +535,13 @@ private void checkgaa(OutputAnalyzer output, String testType, boolean useBarrier
 
         for (String[] test : tests) {
             // non object stores are straightforward
-            if (!useBarriersForVolatile) {
-                // this is the sequence of instructions for all cases
-                matches = new String[] {
-                    "membar_release \\(elided\\)",
-                    test[1] + "_acq",
-                    "membar_acquire \\(elided\\)",
-                    "ret"
-                };
-            } else {
-                // this is the alternative sequence of instructions
-                matches = new String[] {
-                    "membar_release",
-                    "dmb ish",
-                    test[1] + " ",
-                    "membar_acquire",
-                    "dmb ish",
-                    "ret"
-                };
-            }
-
+            // this is the sequence of instructions for all cases
+            matches = new String[] {
+                "membar_release \\(elided\\)",
+                test[1] + "_acq",
+                "membar_acquire \\(elided\\)",
+                "ret"
+            };
             checkCompile(iter, test[0], matches, output, true);
         }
 
@@ -979,40 +549,39 @@ private void checkgaa(OutputAnalyzer output, String testType, boolean useBarrier
 
     // perform a check appropriate to the classname
 
-    private void checkoutput(OutputAnalyzer output, String classname, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
+    private void checkoutput(OutputAnalyzer output, String classname, String testType, boolean useCompressedOops) throws Throwable
     {
         // trace call to allow eyeball check of what is being checked
         System.out.println("checkoutput(" +
                            classname + ", " +
-                           testType + ", " +
-                           useBarriersForVolatile + ")\n" +
+                           testType + ")\n" +
                            output.getOutput());
 
         switch (classname) {
         case "TestVolatileLoad":
-            checkload(output, testType, useBarriersForVolatile, useCompressedOops);
+            checkload(output, testType, useCompressedOops);
             break;
         case "TestVolatileStore":
-            checkstore(output, testType, useBarriersForVolatile, useCompressedOops);
+            checkstore(output, testType, useCompressedOops);
             break;
         case "TestUnsafeVolatileLoad":
-            checkload(output, testType, useBarriersForVolatile, useCompressedOops);
+            checkload(output, testType, useCompressedOops);
             break;
         case "TestUnsafeVolatileStore":
-            checkstore(output, testType, useBarriersForVolatile, useCompressedOops);
+            checkstore(output, testType, useCompressedOops);
             break;
         case "TestUnsafeVolatileCAS":
         case "TestUnsafeVolatileWeakCAS":
-            checkcas(output, testType, useBarriersForVolatile, useCompressedOops);
+            checkcas(output, testType, useCompressedOops);
             break;
         case "TestUnsafeVolatileCAE":
-            checkcae(output, testType, useBarriersForVolatile, useCompressedOops);
+            checkcae(output, testType, useCompressedOops);
             break;
         case "TestUnsafeVolatileGAS":
-            checkgas(output, testType, useBarriersForVolatile, useCompressedOops);
+            checkgas(output, testType, useCompressedOops);
             break;
         case "TestUnsafeVolatileGAA":
-            checkgaa(output, testType, useBarriersForVolatile);
+            checkgaa(output, testType);
             break;
         }
     }
-- 
2.43.0

